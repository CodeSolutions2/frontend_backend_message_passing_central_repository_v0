<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>Timeseries data webapp</h1>
<ol type="A">
	<li>Select a timeseries data source.</li>
	<li>View fetched data.</li>
	<li>Select a model to perform timeseries prediction.</li>
	<li>Predict future time points, evaluate error.</li>
</ol>

<br>
	
<!-- Drop down menu -->
<label for="select_timeseries_data_source">Select a timeseries data source:</label>
<select name="timeseries_data_source" id="timeseries_data_source" style="display:block">
  <option value="---">Select an option</option>
  <option value="Weather_prediction">Weather prediction</option>
  <option value="Custom_URL_endpoint">Custom prediction</option>
</select>
	
<input id="LOCATION" type="text" value="" placeholder="LOCATION: Enter City, Country" rows="10" cols="100" style="display:none; text-align: left; width: 600px;">

<br>
	
<button id="view_fetched_data" onclick="view_fetched_data()">View Fetched Data</button>
  
<br>
	
<!-- Drop down menu -->
<label for="select_model_type">Select a desired model:</label>
<select name="model_type" id="model_type" style="display:block">
  <option value="LSTM">LSTM</option>
  <option value="Forecasting">Forecasting</option>
  <option value="Transformer_based">Transformer_based</option>
</select>

<br>
  
<button id="predict" onclick="predict()">Predict</button>

<div id="notification"></div>
<div id="error"></div>

<!-- --------------------------------------------------- -->
<style>
div { padding: 10px; display:block; font-family:courier; font-size:15px; }
div#notification { position: relative; color: #3236a8; }
div#error { position: relative; color: #bd1f17; }
</style>
	
<!-- --------------------------------------------------- -->

<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});

// -----------------------------------------------

async function processEvent_timeseries_data_source(event) {
	
	if (document.getElementById("timeseries_data_source").selectedIndex == 1) {
		document.getElementById("LOCATION").style.display = 'block';
	} else {
		document.getElementById("LOCATION").style.display = 'none';
	}
}


document.getElementById("timeseries_data_source").addEventListener("change", processEvent_timeseries_data_source, false);
	
// -----------------------------------------------
	
async function view_fetched_data() {

	// Obtain timeseries data
	var timeseries_data_source = document.getElementById("timeseries_data_source").value;
	console.log('timeseries_data_source: ', timeseries_data_source);

	if (timeseries_data_source == 'Weather_prediction') {
		var LOCATION = document.getElementById("LOCATION").value;
		console.log('LOCATION: ', LOCATION);
		
		var Lat_lon_arr = await GET_LATITUDE_LONGITUDE(LOCATION);
		var latitude = Lat_lon_arr.shift();
		
		var obj = await GET_weather_timeseries_data(latitude, Lat_lon_arr);
		
	} else if (timeseries_data_source == 'Custom_URL_endpoint') {
		document.getElementById('notification').innerHTML = "In progress.";
		
	} else {
		document.getElementById('notification').innerHTML = "Please select a timeseries data source."; 
	}

	// -----------------------------------------------
	
	// Predict future data points
	var model_type = document.getElementById("model_type").value;

	if (model_type == 'LSTM') {
		document.getElementById('notification').innerHTML += "model_type In progress.";
		
	} else if (model_type == 'Forecasting') {
		document.getElementById('notification').innerHTML += "model_type In progress.";
		
	} else if (model_type == 'Transformer_based') {
		document.getElementById('notification').innerHTML += "model_type In progress.";
		
	} else {
		document.getElementById('notification').innerHTML = "Please select a model type for timeseries prediction."; 
	}

	// -----------------------------------------------
	
	// Evaluation of prediction with respect to existing prediction

	// -----------------------------------------------
	
}

	

// -----------------------------------------------
	
async function GET_LATITUDE_LONGITUDE(LOCATION) {
	// [Step 0] Get latitude and longitude
	// https://maps.googleapis.com/maps/api/geocode/json?address=${address}&key=${GCP_API_KEY}
	// OR
	// https://nominatim.org/release-docs/latest/api/Search/
	var url = `https://nominatim.openstreetmap.org/search?q=${LOCATION}&format=json`;
	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var headers = {};
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	var out = await fetch_CORS(url, method, data, headers, return_type);
	console.log('out: ', out); 

	// Parse for correct location
	

	
	return [45, 45];
}

// -----------------------------------------------
	
async function GET_weather_timeseries_data(latitude, longitude) {

	// [Step 0] Get weather data
	// https://open-meteo.com/en/docs
	// The API endpoint /v1/forecast accepts a geographical coordinate, a list of weather variables and responds with a JSON hourly weather forecast for 7 days. Time always starts at 0:00 today and contains 168 hours. If &forecast_days=16 is set, up to 16 days of forecast can be returned. All URL parameters are listed below:

	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m`;
	
	method = 'GET';  // method: 'GET', 'POST'
	return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	out = await fetch_CORS(url, method, data, headers, return_type);
	console.log('out: ', out);

	// Parse for timeseries of [past weather] and [predictions of future weather]

	var obj = {past_weather: Array.from({ length: 10 }, (_, ind) => ind),
		  weather_predictions: Array.from({ length: 10 }, (_, ind) => ind)};
	
	return obj;
}

// -----------------------------------------------



	
// -----------------------------------------------
// CORS methods
// -----------------------------------------------
async function fetch_CORS(url, method, data, headers, return_type) {

	// url: url address
	// method: 'GET', 'POST'
	// data: required data format for url address
	var w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	// return_type: json, blob, arrayBuffer, text

	// --------------------------------

	// Determine request method
	var headers_final = {
		"Content-Type": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};

	
	headers_final = Object.assign({}, headers_final, headers);
	
	var options = { 
		method : method,
		mode: 'cors',
		headers: new Headers(headers_final),
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

	if (method == 'POST') {
		options.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.json())
				.then(async function(data) { return data; })
				.catch(error => console.error("error: ", error));
		} else { 
			return await fetch(url, options)
				.then(response => response.json())
				.then(async function(data) { return data; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'arrayBuffer') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { return arraybuffer; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { return arraybuffer; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'text') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		}

	} else if (return_type == 'html') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { return str_data; })
				.catch(error => console.error("error: ", error));
		}
	}

	// --------------------------------
}


async function define_proxy_handler() {
	// Parameters to influence Response Header
	// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
	const handler = {
		apply: function(target, thisArg, args) {
			// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
			const [url, options] = args;
			if (options && options.headers) {
				options.headers['Access-Control-Allow-Origin'] = '*';
				options.headers['Access-Control-Allow-Credentials'] = false;
				options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
				// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
				options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
				options.headers['Access-Control-Max-Age'] = 0;
			} else {
				args[1] = {
					headers: { 
						'Access-Control-Allow-Origin': '*',
						'Access-Control-Allow-Credentials': false,
						'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
						'Access-Control-Allow-Headers': 'Content-Type, Authorization',
						'Access-Control-Max-Age': 0
					}
				};
			}
			// console.log('args: ', args);
			return Reflect.apply(target, thisArg, args);
		}
	};

	// Proxy sturcture works! 
	// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
	// The constant variable is called as a function, where it resolves promises. 
	// Call the constant variable proxy3 as a function to resolve the promise correctly
	return await new Proxy(fetch, handler);
}

// -----------------------------------------------


</script>

  
</body>
</html>
